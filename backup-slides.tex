\documentclass[aspectratio=169]{beamer}
\usetheme{AnnArbor} % Modern clean theme
\usepackage{amsmath, amssymb, amsthm}
\usepackage{quantikz}
\usepackage{stmaryrd}

\title{Quantum Error Correction: Stabiliser Codes}

\subtitle{PHYS/CISC 650 – Step 4 Presentation}
\author{Dhawal}
\date{Fall 2025}

\begin{document}

\maketitle

% -----------------------------
\begin{frame}{Motivation}
Quantum computing platforms:
\begin{itemize}
    \item Photonic qubits \cite{photon-qubit}
    \item Trapped ions \cite{trapped-ion-hyperfine-qubit}
    \item Superconducting qubits, semiconductor spins
\end{itemize}

Challenges:
\begin{itemize}
    \item \textbf{Scalability:} only 100–200 qubits, shallow circuits \cite{quantum-advantage-threshold}
    \item \textbf{Fidelity:} vulnerable to $X, Y, Z$ errors
    \item \textbf{Decoherence:} information stored in correlations → fragile
\end{itemize}
\end{frame}

% -----------------------------
\begin{frame}{Why Error Correction?}
Quantum states cannot be freely copied (No-Cloning Theorem).
\[
A(\alpha|0\rangle + \beta|1\rangle) 
\neq \alpha A|0\rangle + \beta A|1\rangle
\]

Implications:
\begin{itemize}
    \item Cannot use classical redundancy (bit duplication)
    \item Need encoding into larger entangled states
    \item Detect and correct errors without collapsing the state
\end{itemize}
\end{frame}

% -----------------------------
\begin{frame}{Two-Qubit Detection Code}
Encoding:
\[
\alpha |0\rangle + \beta |1\rangle \rightarrow 
\alpha |00\rangle + \beta |11\rangle
\]

Detects bit-flip ($X$) errors, but cannot distinguish where they occurred.

Measurement:
\[
Z_1 Z_2 = 
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & -1 & 0 & 0\\
0 & 0 & -1 & 0\\
0 & 0 & 0 & -1
\end{bmatrix}
\]

Outcome:
\begin{itemize}
    \item $+1 \Rightarrow$ no error
    \item $-1 \Rightarrow$ some error occurred
\end{itemize}
\end{frame}

% -----------------------------
\begin{frame}{Three-Qubit Bit-Flip Code}
Encoding:
\[
| \psi \rangle \otimes |00\rangle \xrightarrow{\text{CNOT}} 
\alpha|000\rangle + \beta|111\rangle
\]

Four orthogonal subspaces:
\[
\mathcal{C}, \mathcal{F}_1, \mathcal{F}_2, \mathcal{F}_3
\]

Syndromes:
\[
\begin{array}{c|c}
\text{Subspace} & A_1 A_2\\
\hline
\mathcal{C} & 00\\
\mathcal{F}_1 & 10\\
\mathcal{F}_2 & 11\\
\mathcal{F}_3 & 01
\end{array}
\]

Corrects any single $X$ error.
\end{frame}

% -----------------------------
\begin{frame}{Stabilizer Codes}
Pauli group $\mathcal{G}_n$:
\[
\{ I, X, Y, Z \}^{\otimes n}
\]

Stabilizer code:
\begin{itemize}
    \item Codespace = $+1$ eigenspace of all stabilizers
    \item Generators commute
    \item $(n,k,d)$ notation
\end{itemize}

Distance $d$:
\[
d = \text{minimum weight of undetectable error}
\]
\end{frame}

% -----------------------------
\begin{frame}{$\llbracket 4,2,2 \rrbracket$ Detection Code}
Smallest stabilizer code detecting both $X$ and $Z$ errors.

\begin{figure}
\centering
\begin{quantikz}
	\lstick{$|\psi\rangle_1$} & \ctrl{2} & & & & \targ{} & 
	\midstick[4]{Encoded} & \gate[4]{E} & \gate[4]{Z} & \gate[4]{X} \\
	\lstick{$|\psi\rangle_2$} & & \ctrl{1} & & \targ{} & & & & & \\
	\lstick{$|0\rangle_3$} & \targ{} & \targ{} & \targ{} & & & & & & \\
	\lstick{$|0\rangle_4$} & \gate{H} & & \ctrl{-1} & \ctrl{-2} & \ctrl{-3} & & & & \\
\end{quantikz}
\end{figure}

Syndrome bits detect error type but cannot correct them because $d=2$.
\end{frame}

% -----------------------------
\begin{frame}{Shor Code: $\llbracket 9,1,3 \rrbracket$}
First quantum error-correcting code (1995).

Encoding:
\[
|0\rangle_{9} = \frac{1}{\sqrt{8}} (|000\rangle + |111\rangle)^{\otimes 3}
\]

Stabilizers include:
\[
Z_1Z_2, Z_2Z_3, \dots,\;
X_1 X_2 X_3 X_4 X_5 X_6, \dots
\]

Corrects \textbf{any} single-qubit error ($d=3$).
\end{frame}

% -----------------------------
\begin{frame}{Syndrome Example (Shor Code)}
If error $X_5$ occurs:

\[
Z_4Z_5, Z_5Z_6 \Rightarrow -1
\]

All other stabilizers return $+1$.

Syndrome:
\[
001100000
\]

Recovery:
\[
Z_4Z_5,\, Z_5Z_6
\]
\end{frame}

% -----------------------------
\begin{frame}{Scalability Challenges}
Stabilizer code issues:
\begin{itemize}
    \item Choosing stabilizers
    \item Constructing codes with good distance
\end{itemize}

Hamming codes:
\[
\llbracket 2^r -1,\; 2^r -1 -2r,\; 3 \rrbracket
\]

Surface codes:
\begin{itemize}
    \item Topological, local interactions
    \item Repeated small patches → scalable
    \item High noise threshold
    \item But: low encoding density, many physical qubits needed
\end{itemize}
\end{frame}

% -----------------------------
\begin{frame}{Other Correction Algorithms}
Requirements for practical quantum processors:
\begin{itemize}
    \item High noise threshold
    \item Universal logical gate set
    \item Low qubit overhead per logical qubit
    \item Fast error correction cycles
\end{itemize}

Low-Density Parity-Check (LDPC) codes:
\begin{itemize}
    \item Sparse parity checks
    \item Lower resource overhead
    \item Growing research interest
\end{itemize}

\end{frame}

% -----------------------------
\begin{frame}{Conclusion}
\begin{itemize}
    \item QEC is essential for scalable quantum computation
    \item Early codes (3-qubit, Shor) illustrate basic principles
    \item Stabilizer formalism unifies many codes
    \item Surface codes dominate current hardware implementations
    \item LDPC codes may significantly reduce qubit overhead in the future
\end{itemize}

\centering \textbf{Questions?}
\end{frame}

% -----------------------------
\bibliographystyle{plain}
\bibliography{myref.bib}

\end{document}
